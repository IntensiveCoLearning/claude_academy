---
timezone: UTC+8
---

# ray

**GitHub ID:** rayjun

**Telegram:** @rayoo_eth

## Self-introduction

A Builder

## Notes

<!-- Content_START -->
# 2025-07-29

对于 MCP Server ，有三个重要的组件：

- Tools：面向大模型，为大模型提供额外的能力
- Resources：面向应用，可以在应用中获取额外的数据，丰富与大模型交互的上下文信息，这里其实也可以理解为 MCP Server 的提供方想暴露出来的数据
- Prompts：MCP Server 可以内置一些 Prompts，帮助用户提高任务的处理效率，对于 MCP Server 的开发则者来说，提供 Prompts 很重要，因为直接可以决定用户使用这个 MCP Server 的体验

我使用大模型的个人体验是，大模型的输出质量可能与输入有直接的关系，其实这里 考验的就是人的表达能力，能不能把一个问题或者需求描述清晰，越清晰、上下文约丰富，那么 AI 的输出就会质量越高。所以现在只有 Vibe coding 已经不够了，需要 Spec-Driven 的方式来把输入标准化，让输入产生的歧义越少，那么大模型的输出就会越确定。

# 2025-07-28

有了 MCP 开发框架之后，开发一个 MCP Server 就像开发一个普通的服务程序一样简单，对于一些有着数据的场景，可以非常轻松地将数据和 AI 大模型集成起来，然后做成一个可以交互的应用，但这个看起来只是一个很初级的应用或者说一个 Demo。从另外一个角度看， MCP 将 AI 与数据交互的流程标准化了，但是这个 标准化的流程不只是人可以用，AI 也可以用，或者说更适合 AI 使用，然后诸多的 MCP Server 和 Client 之间可以组成一个新的调用链。如果按照软件中没有解决不了的问题，如果有，就加一个中间层来解决问题的思路，那么就可以认为，对 AI 来说，就没有解决不了的问题了。

这么来看，这是一个很有潜力的场景，因为 AI 可以通过 MCP 来不断进化，连接一切，而且这个进化和学习的速度会远超人类。

# 2025-07-25

MCP 的设计思想符合软件工程中的经典做法，**没有什么软件上的问题是增加中间层解决不了的问题，如果有，那就再加一层**。增加中间层的本质就是屏蔽复杂性，既然用户享受到了 MCP 的便利性，那么复杂性自然由提供 MCP 的人来承担，Java 语言中的 JVM，以太坊中的 EVM 都是类似的设计思想。

MCP Client 和 MCP Server 之间的交互依然是一个很经典的协议设计，在 MCP Client 在提出具体的请求之前，会先确认 MCP Server 有哪些能力，然后再从中挑选一个当前用户请求最需要的能力去做具体的事情。这种设计在网络协议的设计中也很常见，比如在以太坊的两个节点之间交互时，会先发送请求去确认当前节点支持的协议版本，然后从中挑选两个节点双方都支持的一种协议开始后续的交互。

# 2025-07-24

今天开始在看 MCP 的视频，突然想到另外一种理解 MCP 的方式，其实某种程度上，大模型本身也是封闭的，持有的信息只到它被生成的那一刻，从那以后就是一个封闭的系统，从这个角度上来看和区块链是一致的。它们的相似点在于：

- 大模型和区块链都有获取现实世界新信息的需求，而无法依靠自身做到
- 区块链可以依赖预言机，而大模型依赖 MCP，本质上都是讲数据标准化，然后以系统能够理解的方式传到大模型或者区块链
- 这个需求会持续存在，但真正有价值的还是数据，而不是预言机或者 MCP 本身


顺便说一下，当前这个学习打卡的模式真的太丝滑了，非常适合新手，如果能优化一下 makrdwon 的语法提示和编辑就更棒了。
<!-- Content_END -->
